# %%
import os, math
import argparse
from PIL import Image
import numpy as np
from pathlib import Path
import time


def getBinaryData(filename):
	"""
		Get byte sequence from ELF file
	"""

	p = Path(filename)
	bin_v = p.read_bytes()
	binary_val = list(bin_v)
  
	return binary_val


def save_file(filename, data, size, image_type, type, method):
	"""
		Save byte sequence to png image
	"""
	try:
		image = Image.new(image_type, size)
		image.putdata(data)

		# setup output filename
		name = filename.split('/')[-1]
		# image_name = dirname + os.sep + image_type + os.sep + name + '_'+image_type+ '.png'
		image_path = os.path.join('/media/islab/media_1/jyang/dataset_20220718/img_data', type+'_'+method+'_'+str(size[0])+'_'+image_type)
		# print('image_path: ', image_path)
		os.makedirs(image_path, exist_ok=True)
		image_name = os.path.join(image_path, f'{name}_{image_type}.png')
		# print('image_name: ', image_name)
		image.save(image_name)
		# print(f'The file {image_name} saved.')
	except Exception as err:
		print('\nerr: ', err)


def get_size(data_length, width=None):
	"""
		Convert byte length to fixed image size
	"""
	# source Malware images: visualization and automatic classification by L. Nataraj
	# url : http://dl.acm.org/citation.cfm?id=2016908
	# https://github.com/ncarkaci/binary-to-image/blob/master/binary2image.py

	if width is None: # with don't specified any with value
		size = data_length

		if size < 10 * 1e3:
			width = 32
		elif (size >= 10 * 1e3 and size < 30 * 1e3):
			width = 64
		elif (size >= 30 * 1e3 and size < 60 * 1e3):
			width = 128
		elif (size >= 60 * 1e3 and size < 100 * 1e3):
			width = 256
		elif (size >= 100 * 1e3 and size < 200 * 1e3):
			width = 384
		elif (size >= 200 * 1e3 and size < 500 * 1e3):
			width = 512
		elif (size >= 500 * 1e3 and size < 1000 * 1e3):
			width = 768
		elif (size >= 1000 * 1e3 and size < 2000 * 1e3):
			width = 1024
		elif (size >= 2000 * 1e3):
			width = 2048

		height = int(size / width) + 1
	else:
		width  = int(math.sqrt(data_length)) + 1
		height = width

	# width = 64
	height = int(data_length / width) + 1
	# print('width: ', width, '\theigh: ', height)
	
	return (width, height)

def createGreyTruncateScaleImage(type, size):
	start = time.time()
	pth = '/media/islab/media_1/jyang/dataset_20220718/img_data'
	image_path = os.path.join(pth, type)
	bin = [os.path.join(image_path, _) for _ in os.listdir(image_path)]
	total = len(bin)
	PAD_VALUE = int("00", 16)
	for idx, i in enumerate(bin, start=1):
		print(f'\r\033[36;1m({idx}/{total}), {(idx/total)*100:.2f}%, filename: {i.split("/")[-1]}\033[0m', end='')
		greyscale_data = getBinaryData(i)
		# print('greyscale_data: ', len(greyscale_data))

		max_size = size[0]*size[1]
		# print('\nmax_size: ', max_size, '\tlen(greyscale_data): ', len(greyscale_data), max_size > len(greyscale_data))
		if max_size > len(greyscale_data):
			pad_width = [(0, max_size-len(greyscale_data))]
			greyscale_data = np.pad(greyscale_data, pad_width, mode='constant', constant_values=PAD_VALUE)
			greyscale_data = greyscale_data[:max_size]	# padding
		else:
			greyscale_data = greyscale_data[:max_size]	# truncate
		# print('greyscale_data: ', len(greyscale_data))

		save_file(i, greyscale_data, size, 'L', type, 'trun')	# L (8-bit pixels, black and white)

	end = time.time() - start
	print('\nrun times: {:.0f}m {:.5f}s'.format(end//60, end%60))


# def adjustSize(greyscale_data, size):
#   # resizeingz
#   pass


# [image mode](https://pillow.readthedocs.io/en/stable/handbook/concepts.html#concept-modes)
def createGreyScaleImage(type, width=None):
  """
  	Create greyscale image from 8 bit binary data
  """
  start = time.time()
  pth = '/media/islab/media_1/jyang/dataset_20220718/img_data'
  image_path = os.path.join(pth, type)
  bin = [os.path.join(image_path, _) for _ in os.listdir(image_path)][:5]
  total = len(bin)
  for idx, i in enumerate(bin, start=1):
    print(f'\r\033[36;1m({idx}/{total}), {(idx/total)*100:.2f}%, filename: {i.split("/")[-1]}\033[0m', end='')
    greyscale_data = getBinaryData(i)
    # print('greyscale_data: ', len(greyscale_data))

    size = get_size(len(greyscale_data), width)
    # print('size: ', size)

    save_file(i, greyscale_data, size, 'L', type, 're')	# L (8-bit pixels, black and white)
  
  end = time.time() - start
  print('\nrun times: {:.0f}m {:.5f}s'.format(end//60, end%60))


def createRGBImage(type, width=None):
	"""
		Create RGB image from 24 bit binary data 8bit Red, 8 bit Green, 8bit Blue
	"""
	start = time.time()
	pth = '/media/islab/media_1/jyang/dataset_20220718/img_data'
	image_path = os.path.join(pth, type)
	bin = [os.path.join(image_path, _) for _ in os.listdir(image_path)]
	total = len(bin)
	for idx, i in enumerate(bin, start=1):
		print(f'\r\033[36;1m({idx}/{total}), {(idx/total)*100:.2f}%, filename: {i.split("/")[-1]}\033[0m', end='')
		index = 0
		rgb_data = list()
		binary_data = getBinaryData(i)

		# Create R,G,B pixels
		while (index + 3) < len(binary_data):
			R = binary_data[index]
			G = binary_data[index+1]
			B = binary_data[index+2]
			index += 3
			rgb_data.append((R, G, B))
		
		size = get_size(len(rgb_data), width)
		save_file(i, rgb_data, size, 'RGB', type, 're')

	end = time.time() - start
	print('\nrun times: {:.0f}m {:.5f}s\n'.format(end//60, end%60))


if __name__=='__main__':
  # WIDTH = None
  # print(f'\033[32;1m[+] Create Grey Scale Image mirai \033[0m')
  # createGreyScaleImage('linuxmal_selected', WIDTH)

  # print(f'\033[32;1m[+] Create Grey Scale Image benign \033[0m')
  # createGreyScaleImage('benignware', WIDTH)

	# size = (128, 128)
	size = (256, 256)
	print(f'\033[32;1m[+] Create Grey Truncate Scale Image mirai {size} \033[0m')
	createGreyTruncateScaleImage('linuxmal_selected', size)

	print(f'\033[32;1m[+] Create Grey Truncate Scale Image benign {size} \033[0m')
	createGreyTruncateScaleImage('benignware_selected', size)